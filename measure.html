<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Formula Measuring Tool</title>
    <style>
        /* General Setup */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            color: #333;
            min-height: 100vh;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin: 10px 0 20px 0;
        }

        /* --- NEW LAYOUT: Sidebar + Main Content (Desktop Default) --- */
        .main-app {
            display: flex;
            min-height: 100vh; 
            padding: 20px;
            gap: 20px;
            box-sizing: border-box;
        }
        .controls {
            width: 280px; 
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
            overflow-y: auto;
        }
        .visual-area {
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: hidden; 
            box-sizing: border-box;
        }
        /* --- End NEW LAYOUT --- */
        
        /* === MOBILE FIX: MEDIA QUERY for stacking layout (Up to 768px wide) === */
        @media (max-width: 768px) {
            .main-app {
                /* Stack elements vertically */
                flex-direction: column;
                padding: 10px; /* Reduce overall padding */
            }
            .controls {
                /* Allow controls to take full width */
                width: 100%; 
                height: auto; 
                order: 1; /* Place inputs first */
            }
            .visual-area {
                /* Allow visual area to take full width */
                width: 100%;
                order: 2; /* Place visualization second */
            }
        }

        /* === MOBILE FIX: MEDIA QUERY for cramped text overlap (Up to 420px wide) === */
        @media (max-width: 420px) {
            /* Targeting all spans in the visualization table */
            #visualTable span {
                /* Aggressively reduce font size to prevent overlap */
                font-size: 8px !important; 
                padding: 2px;
            }
        }
        /* ============================== */

        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group.calculate-group {
            margin-top: 15px;
            border-top: 1px dashed #ccc;
            padding-top: 15px;
        }
        .control-group label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 14px;
        }
        .control-group input,
        .control-group select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            background-color: white;
            margin-bottom: 5px;
        }
        .control-group input[disabled] { 
            background-color: #ecf0f1;
            color: #7f8c8d;
            border-style: dashed;
        }
        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.2);
        }
        /* Signage Options */
        .signage-options {
            padding: 10px 0;
            border-top: 1px dotted #e0e0e0;
            margin-top: 5px;
            /* Re-enabling the toggle, hiding the obsolete inputs */
            display: flex; 
            flex-direction: column;
            gap: 10px;
        }
        .signage-options .hidden-control {
            display: none;
        }
        #visualizeBtn {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            background-color: #007aff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 20px;
        }
        #visualizeBtn:hover {
            background-color: #0056b3;
        }

        /* Unit specific styling */
        .unit-display {
            font-size: 10px;
            color: #7f8c8d;
            margin-top: -3px;
            font-weight: normal;
        }
        .warning-text {
            font-size: 10px;
            color: #d35400;
            margin-top: -5px;
            margin-bottom: 5px;
        }

        /* Visual representation styling */
        .visual-container {
            cursor: grab; 
            flex-grow: 1; 
            padding: 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: auto; 
            position: relative;
            padding-top: 20px; 
            user-select: none; 
        }
        .visual-container:active {
            cursor: grabbing;
        }
        .table-wrapper {
            transform-origin: left top;
            transition: transform 0.1s ease-out; 
            min-width: 100%; 
        }
        .table {
            width: 100%;
            height: 150px; 
            display: flex;
            align-items: flex-end; 
            background-color: #ecf0f1;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            box-sizing: border-box;
        }
        /* Universal box-sizing for visual elements */
        .item, .space, .signage, .sign-gap, .circle-sign, .rectangle-item, .item-sign-gap, .internal-gap {
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            font-weight: 600;
            white-space: nowrap;
            position: relative; 
        }

        /* Modify .item to be a transparent container */
        .item {
            background-color: transparent !important; 
            border: none !important; 
            height: 100%; 
            position: relative;
            display: flex; 
            align-items: center;
            justify-content: center;
        }
        
        /* Space block styling - Light blue/gray for spacing */
        .space {
            background-color: #b3cde0; 
            height: 50px;
            /* Ensure space block starts at the bottom baseline */
            align-self: flex-end; 
            align-items: flex-start;
        }
        
        /* --- Styles for Screenshot Elements (Circle = Sign, Rectangle = Item) --- */

        /* Circle represents the Sign */
        .circle-sign {
            background-color: #cfd8dc; 
            border: 2px solid #333;
            border-radius: 50%;
            height: 40px;
            color: #333;
        }

        /* Rectangle represents the Item */
        .rectangle-item {
            background-color: #e9ecef; 
            border: 2px solid #333;
            height: 80px;
            color: #333;
            align-items: center; 
        }
        
        /* The 1-inch gap between the sign and the item */
        .item-sign-gap {
            background-color: transparent; 
            height: 100%;
        }
        
        /* UPDATED: Styling for the gap between items inside a solution group (D) */
        .internal-gap {
            background-color: #d1e2c4; /* Soft green/yellow for visibility */
            height: 50px; 
            opacity: 0.9; 
            /* CRUCIAL FIX: Align the internal gap block to the BOTTOM baseline */
            align-self: flex-end; 
            align-items: flex-start;
        }
        .internal-gap span {
            /* High contrast text against the light background */
            font-size: 10px;
            color: #000; /* Black text for readability */
            padding: 2px 4px;
            background: #fff; /* White background for text chip */
            border-radius: 3px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.15);
            /* NEW FIX: Lift the label much higher than the default -20px */
            top: -55px; 
            transform: none; 
        }


        /* Hide old signage elements */
        .signage, .sign-gap {
            display: none !important; 
        }


        /* The span inside every measurement block is the target for inverse scaling */
        .item span, .space span, .circle-sign span, .rectangle-item span, .item-sign-gap span, .internal-gap span {
            padding: 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
            transform-origin: center;
            position: absolute;
            z-index: 10;
        }

        /* Item container label (unused for measurement but kept) */
        .item span {
            top: -20px; 
            background: rgba(0,0,0,0.2);
            color: #fff;
            padding: 2px 4px;
        }

        /* Space label (Top position) */
        .space span {
            top: -20px;
            background: rgba(255, 255, 255, 0.9);
            color: #222;
            padding: 2px 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.15);
        }

        /* Span inside the new elements (Signs/Items) */
        .circle-sign span, .rectangle-item span, .item-sign-gap span {
            font-size: 10px; 
            color: #333; 
            padding: 2px 4px;
            background: rgba(255, 255, 255, 0.8); 
            border-radius: 2px;
        }
        
        /* Sign label (Bottom position) */
        .circle-sign span {
            top: 100%; 
        }
        
        /* Item rectangle label (Bottom position) */
        .rectangle-item span {
            top: 100%; 
            background: rgba(255, 255, 255, 0.8);
            color: #333;
            box-shadow: none;
        }

        /* Gap label (Centered vertically within its block) */
        .item-sign-gap span {
            top: 50%;
        }

        /* Base transform set to identity. JS will handle scaling and offsetting. */
        .rectangle-item span, .space span, .circle-sign span, .item-sign-gap span, .internal-gap span {
            transform: none; 
        }
        
        /* Zoom Controls Styling */
        .zoom-controls {
            /* Inherit the card styling for its own area */
            padding: 15px 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            /* Reset absolute positioning */
            position: relative;
            top: auto; 
            left: auto;
            right: auto;
            /* Flex layout */
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px; /* Space between controls and visual table */
        }
        .zoom-controls label {
             font-weight: 600;
             font-size: 14px;
             white-space: nowrap;
        }
        .zoom-controls button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        #zoomSlider {
            flex-grow: 1;
            /* Disable the browser's default scrolling/panning when touching the slider */
            touch-action: none; 
            /* Give the input element more height */
            height: 30px; 
        }

        /* === Range Slider Styling for Improved Touch === */
        /* Target the THUMB (the draggable handle) across different browsers */
        #zoomSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;   /* Make the thumb wider */
            height: 25px;  /* Make the thumb taller */
            border-radius: 50%;
            background: #007aff;
            cursor: pointer;
            border: 2px solid #fff; 
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            margin-top: -8px; /* Correctly center the thumb vertically on the track */
        }
        
        #zoomSlider::-moz-range-thumb {
            width: 25px; 
            height: 25px;
            border-radius: 50%;
            background: #007aff;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        /* Target the TRACK (the bar the thumb slides on) for better visual feedback */
        #zoomSlider::-webkit-slider-runnable-track {
            height: 10px; 
            border-radius: 5px;
            background: #ccc;
        }
        
        #zoomSlider::-moz-range-track {
            height: 10px;
            border-radius: 5px;
            background: #ccc;
        }
        /* ================================================= */

        #zoomLevelDisplay {
            width: 50px;
            text-align: right;
            font-weight: 600;
        }
    </style>
</head>
<body>
    
    <div class="main-app">
        <div class="controls">
            <h2>⚙️ Calculation Inputs</h2>

            <div class="control-group">
                <label for="lengthSourceSelect">1. Length of Table (A):</label>
                <select id="lengthSourceSelect">
                    <option value="10ft" selected>Set Length (10 Feet)</option>
                    <option value="custom">Custom Length (Input A)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="varA">Variable A (Custom Length in Feet):</label>
                <input type="number" id="varA" value="12">
                <span class="unit-display" id="varAUnitDisplay">144.00 in. (Used in calculation)</span>
            </div>
            
            <div class="control-group">
                <label for="manualSolutionCount">2. Total Number of Solution Groups:</label>
                <input type="number" id="manualSolutionCount" value="3" min="0">
                <p class="warning-text">Enter the number of groups you want.</p>
            </div>
            
            <div class="control-group">
                <label for="itemWidthsInput">3. Item Pattern (e.g., 12,20; 10; 12,15):</label>
                <input type="text" id="itemWidthsInput" value="12,20; 10; 12,15">
                <p class="warning-text">Enter item widths separated by commas. Use ';' to divide them into groups matching the count above.</p>
            </div>
            
            <div class="control-group">
                <label for="itemGapInput">4. Item-to-Item Gap (D) in in.:</label>
                <input type="number" id="itemGapInput" value="1.0">
                <p class="warning-text">Space applied between items WITHIN a solution group.</p>
            </div>

            <div class="control-group">
                <label for="signageToggle">5. Signage Used?</label>
                <select id="signageToggle">
                    <option value="false">No</option>
                    <option value="true" selected>Yes</option>
                </select>
                <p class="warning-text">If 'Yes', a sign and gap are added to the LEFT of the first item in EACH group.</p>
            </div>
            
            <div class="control-group">
                <label for="numSigns">Number of Signs Calculated:</label>
                <input type="text" id="numSigns" value="0" disabled>
                <p class="warning-text">Count calculated automatically based on Group count and Signage Toggle.</p>
            </div>
            
            <div class="control-group hidden-control">
                <label for="itemsPerSign">Items per Sign:</label>
                <input type="number" id="itemsPerSignInput" value="1" disabled>
            </div>
            <div class="control-group calculate-group">
                <label for="varB">7. Variable B (Sum of all Solutions):</label>
                <input type="text" id="varB" value="0" disabled>
                <span class="unit-display" id="varBUnit">0.00 ft / 0.00 in.</span>
            </div>

            <div class="control-group">
                <label for="edgeFactorSelect">8. Choose the Edge Factor:</label>
                <select id="edgeFactorSelect">
                    <option value="1">X</option>
                    <option value="0.5" selected>X / 2</option>
                    <option value="0">0 (No End Spacing)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="formulaSelect">9. Select Spacing Formula:</label>
                <select id="formulaSelect">
                    <option value="formula-1">Formula 1: (A - B) / TotalGaps = X</option> 
                    <option value="formula-2">Formula 2: Fixed C on Ends (Old)</option>
                    <option value="formula-3">Formula 3: (A - X) / N (Old)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="varC">Variable C (Space between Solutions):</label>
                <input type="number" id="varC" value="4">
            </div>
            
            <div class="control-group">
                <label for="varX">Variable X (Calculated Space):</label>
                <input type="text" id="varX" value="0" disabled>
                <span class="unit-display" id="varXUnit">0.00 ft / 0.00 in.</span>
                <span class="unit-display" id="varXFractional" style="font-weight: 600; color: #3498db; margin-top: 5px;">Fractional Value: 0 in.</span>
            </div>
            
            <button id="visualizeBtn">Recalculate & Visualize</button>

        </div>

        <div class="visual-area">
            <h1>Dynamic Spacing Visualization</h1>

            <div class="zoom-controls">
                <label>Zoom Level:</label>
                <button onclick="changeZoom(-0.1)">➖</button>
                <input type="range" id="zoomSlider" min="1" max="5" value="1" step="0.1">
                <button onclick="changeZoom(0.1)">➕</button>
                <span id="zoomLevelDisplay">100%</span>
                <button onclick="resetZoom()">Reset</button>
            </div>
            <div class="visual-container" id="visualContainer">
                
                <div id="tableWrapper" class="table-wrapper">
                    <div id="visualTable" class="table">
                        </div>
                </div>

                <p style="margin-top: 20px;">The total layout sum (B + total spacing) must equal Variable A (Length of Table).</p>
            </div>
        </div>
    </div>


    <script>
        // Constants
        const INCHES_PER_FOOT = 12;
        const SET_LENGTH_FEET = 10;
        // Constants for the fixed-width sign and gap components
        const SIGN_WIDTH_INCHES = 3; 
        const SIGN_ITEM_GAP_INCHES = 1; 
        const DEFAULT_ZOOM = 1.0;

        // Get references to ALL our HTML elements
        const lengthSourceSelect = document.getElementById('lengthSourceSelect'); 
        const varAInput = document.getElementById('varA');
        const varAUnitDisplay = document.getElementById('varAUnitDisplay');
        const varBInput = document.getElementById('varB');
        const varBUnitDisplay = document.getElementById('varBUnit');
        const varCInput = document.getElementById('varC');
        const edgeFactorSelect = document.getElementById('edgeFactorSelect');
        const varXInput = document.getElementById('varX');
        const varXUnitDisplay = document.getElementById('varXUnit');
        const varXFractionalDisplay = document.getElementById('varXFractional'); 
        const itemWidthsInput = document.getElementById('itemWidthsInput');
        const manualSolutionCountInput = document.getElementById('manualSolutionCount'); 
        const numSignsInput = document.getElementById('numSigns'); // Used for display only
        const signageToggle = document.getElementById('signageToggle'); // Re-enabled
        const itemGapInput = document.getElementById('itemGapInput'); // NEW Item Gap Input
        
        // Zoom Elements
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');
        
        let currentZoomLevel = DEFAULT_ZOOM;
        
        // Helper function to check for narrow mobile screens (Direct window width check)
        function isNarrowScreen() {
             return window.innerWidth <= 420;
        }

        // --- Event Listener for window resize to fix mobile display immediately ---
        window.addEventListener('resize', updateVisualization);
        // --- END Event Listener ---
        
        /**
         * Converts decimal inches to the nearest fractional representation.
         */
        function decimalToFraction(decimal, denominator = 16) {
            if (isNaN(decimal)) return 'N/A';
            
            // Separate whole number and fraction
            let whole = Math.floor(decimal);
            const fractionPart = decimal - whole;
            
            // Convert fraction part to the nearest specified denominator
            let numerator = Math.round(fractionPart * denominator);
            
            // Handle rounding up to the next whole number
            if (numerator >= denominator) {
                numerator -= denominator;
                whole += 1;
            }
            
            // Simplify the fraction (e.g., 8/16 becomes 1/2)
            function simplify(num, den) {
                let gcd = 0; // Greatest Common Divisor
                let temp = 0;
                let a = num;
                let b = den;

                while (b !== 0) {
                    temp = b;
                    b = a % b;
                    a = temp;
                }
                gcd = a;

                return `${num / gcd}/${den / gcd}`;
            }

            if (numerator === 0) {
                return `${whole} in.`;
            }
            
            const fractionalString = simplify(numerator, denominator);
            
            return whole > 0 ? `${whole} ${fractionalString} in.` : `${fractionalString} in.`;
        }


        // --- ZOOM FUNCTIONS ---
        function applyZoom() {
            // Scale the wrapper to zoom the content horizontally
            tableWrapper.style.transform = `scaleX(${currentZoomLevel})`;
            // Increase wrapper width to allow horizontal scrolling
            tableWrapper.style.width = `${100 * currentZoomLevel}%`; 
            zoomLevelDisplay.textContent = `${(currentZoomLevel * 100).toFixed(0)}%`;
            
            // Calculate the inverse scale for transformation
            const inverseScale = 1 / currentZoomLevel;
            
            // Calculate the desired font size based on zoom level. 
            const baseFontSize = 12; 
            const newFontSize = baseFontSize * Math.sqrt(currentZoomLevel) * 0.8; 

            // Target all measurement labels (spans)
            const spanElements = visualTable.querySelectorAll('span');
            
            const isMobile = isNarrowScreen();

            spanElements.forEach(span => {
                
                if (!isMobile) {
                    // Only apply the dynamic font size on wider screens (desktop/tablet)
                    span.style.fontSize = `${newFontSize.toFixed(1)}px`;
                } 

                // Determine the parent element type
                const parentType = span.parentElement.className;
                
                // All labels need inverse scaling for non-stretching text
                let transformValue = `scaleX(${inverseScale})`;

                // Apply vertical offset based on element type
                if (parentType === 'rectangle-item' || parentType === 'circle-sign') {
                    // Item and Sign labels: Inverse X scaling + 5px vertical offset for bottom alignment
                    transformValue = `scaleX(${inverseScale}) translateY(5px)`;
                } else if (parentType === 'item-sign-gap') {
                    // Gap label: Inverse X scaling + fixed vertical offset (15px) 
                    transformValue = `scaleX(${inverseScale}) translateY(15px)`;
                } else if (parentType === 'internal-gap') {
                    // Internal Gap label: Inverse X scaling + centered vertical offset
                    transformValue = `scaleX(${inverseScale}) translateY(-50%)`;
                }
                // Top-aligned labels (space) default to just scaleX

                span.style.transform = transformValue;
            });
        }

        window.changeZoom = function(delta) { 
            let newZoom = currentZoomLevel + delta;
            newZoom = Math.min(Math.max(newZoom, parseFloat(zoomSlider.min)), parseFloat(zoomSlider.max));
            zoomSlider.value = newZoom;
            currentZoomLevel = newZoom;
            applyZoom();
        }

        window.resetZoom = function() { 
            zoomSlider.value = DEFAULT_ZOOM;
            currentZoomLevel = DEFAULT_ZOOM;
            applyZoom();
            visualContainer.scrollLeft = 0; 
        }
        
        zoomSlider.addEventListener('input', () => {
            currentZoomLevel = parseFloat(zoomSlider.value);
            applyZoom();
        });
        
        // --- DRAGGABLE/PANNING LOGIC ---
        let isDragging = false;
        let startX = 0;
        let scrollLeft = 0;

        visualContainer.addEventListener('mousedown', (e) => {
            // NOTE: Since the slider is moved, no need to check e.target.closest('.zoom-controls') anymore
            isDragging = true;
            startX = e.pageX - visualContainer.offsetLeft;
            scrollLeft = visualContainer.scrollLeft;
            visualContainer.style.cursor = 'grabbing';
        });

        visualContainer.addEventListener('mouseleave', () => {
            isDragging = false;
            visualContainer.style.cursor = 'grab';
        });

        visualContainer.addEventListener('mouseup', () => {
            isDragging = false;
            visualContainer.style.cursor = 'grab';
        });

        visualContainer.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const x = e.pageX - visualContainer.offsetLeft;
            const walk = (x - startX) * 1.5; 
            visualContainer.scrollLeft = scrollLeft - walk;
        });
        // --- END DRAGGABLE LOGIC ---


        // Helper functions
        function convertInchesToFeet(inches) {
            return inches / INCHES_PER_FOOT;
        }
        function convertFeetToInches(feet) {
            return feet * INCHES_PER_FOOT;
        }

        // Toggles visibility of signage options (Now handled implicitly by updateVisualization call)
        function toggleSignageOptions() {
            updateVisualization(); 
        }
        
        // Attach event listeners
        const inputsToListen = [lengthSourceSelect, varAInput, varCInput, edgeFactorSelect, formulaSelect, itemWidthsInput, manualSolutionCountInput, signageToggle, itemGapInput]; // Added itemGapInput
        inputsToListen.forEach(input => input.addEventListener('change', updateVisualization));
        visualizeBtn.addEventListener('click', updateVisualization);
        
        document.addEventListener('DOMContentLoaded', () => {
             // Disable obsolete controls
             document.getElementById('itemsPerSignInput').disabled = true;
             // Set up initial state
             updateVisualization(); 
             resetZoom(); 
        }); 

        
        // -------------------------------------------------------------------
        //  FORMULA LOGIC SECTION (All calculations use inches)
        // -------------------------------------------------------------------
        /**
         * Calculates the array of space widths based on the selected formula and variables.
         */
        function calculateSpacing(A_inches, B_totalWidth, C, numSolutions, formulaId, edgeFactor) {
            
            if (B_totalWidth > A_inches) {
                return null;
            }
            
            let calculatedX = 0; 
            let spaceWidths = [];

            if (formulaId === "formula-1") {
                // FORMULA 1: X = (A - B) / TotalGaps
                const numInternalGaps = Math.max(0, numSolutions - 1);
                const totalXSegments = numInternalGaps + (edgeFactor * 2);

                if (totalXSegments <= 0) return null; 
                
                calculatedX = (A_inches - B_totalWidth) / totalXSegments;
                
                if (calculatedX < 0) return null;

                const edgeSpace = calculatedX * edgeFactor;
                
                spaceWidths.push(edgeSpace);
                
                for (let i = 0; i < numInternalGaps; i++) {
                    spaceWidths.push(calculatedX);
                }
                
                if (numSolutions > 0 || edgeFactor > 0) {
                     spaceWidths.push(edgeSpace);
                }
                
            } else if (formulaId === "formula-2") {
                // FORMULA 2: Fixed C inches on the ends, equal spacing in between.
                
                const fixedEndSpace = C * 2;
                const remainingInternalSpace = A_inches - B_totalWidth - fixedEndSpace;
                
                if (remainingInternalSpace < 0) return null;
                
                const numInternalSpaces = Math.max(0, numSolutions - 1); 
                
                const internalSpaceWidth = (numInternalSpaces > 0) 
                    ? (remainingInternalSpace / numInternalSpaces) 
                    : 0;
                
                spaceWidths = [C]; 
                for(let i = 0; i < numInternalSpaces; i++) {
                    spaceWidths.push(internalSpaceWidth); 
                }
                spaceWidths.push(C); 
                calculatedX = internalSpaceWidth; 
            
            } else if (formulaId === "formula-3") {
                // FORMULA 3: (A - X) / N
                const X_input = parseFloat(varXInput.value); 
                
                const workingWidth = A_inches - X_input;
                const remainingSpace = workingWidth - B_totalWidth;

                if (remainingSpace < 0) return null;

                const maxSpacingPerInternalGap = (numSolutions > 0) ? remainingSpace / numSolutions : remainingSpace;
                
                spaceWidths = new Array(numSolutions).fill(maxSpacingPerInternalGap);
                spaceWidths.push(X_input); 
                
                calculatedX = X_input; 
            }
            
            // Handle the "no solutions" case
            if (numSolutions === 0) {
                 spaceWidths = [A_inches];
                 calculatedX = 0; 
            }
            
            if (spaceWidths.length === 0) return null;

            return { spaceWidths: spaceWidths, calculatedX: calculatedX };
        }


        /**
         * Parses the item widths input string into an array of item groups.
         * The total number of groups must match manualSolutionCount.
         */
        function parseItemGroups(inputStr, expectedGroups) {
            // Split by ';' to define groups
            const rawGroups = inputStr.split(';');
            const parsedGroups = [];
            
            // Use the expectedGroups count to control the overall loop structure
            for (let g = 0; g < expectedGroups; g++) {
                const groupStr = rawGroups[g] ? rawGroups[g].trim() : "";
                
                const items = groupStr.split(',').map(itemStr => itemStr.trim());
                const currentGroup = [];

                // Check if the current group has any valid items
                let hasValidItems = false;
                
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    const width = parseFloat(item);
                    
                    if (isNaN(width) || width <= 0) continue; 
                    
                    // The 'isFirst' flag is true only for the very first valid item in this group
                    const isFirstValidItem = currentGroup.length === 0;

                    // Store item width and whether it is the item that precedes the sign/gap
                    currentGroup.push({ width: width, isFirst: isFirstValidItem });
                    hasValidItems = true;
                }
                
                if (hasValidItems) {
                    parsedGroups.push(currentGroup);
                }
            }
            
            // NOTE: The main updateVisualization loop uses itemGroups.length for drawing/spacing calculation.
            return parsedGroups;
        }


        /**
         * Main function to update the visual representation
         */
        function updateVisualization() {
            visualTable.innerHTML = ''; 
            
            const isMobile = isNarrowScreen();

            // 1. DETERMINE A (Total Length)
            const source = lengthSourceSelect.value;
            let A_feet;

            if (source === '10ft') {
                A_feet = SET_LENGTH_FEET;
                varAInput.disabled = true;
                varAInput.value = A_feet;
            } else { 
                A_feet = parseFloat(varAInput.value);
                varAInput.disabled = false;
            }
            
            const A_inches = convertFeetToInches(A_feet);
            const C = parseFloat(varCInput.value);
            const edgeFactor = parseFloat(edgeFactorSelect.value);
            const selectedFormula = formulaSelect.value; 
            const D = parseFloat(itemGapInput.value) || 0; // NEW: Item-to-Item Gap (D)

            // Check Signage Toggle State
            const isSignageOn = signageToggle.value === 'true';
            
            // 2. GET GROUP COUNT
            const expectedSolutionGroups = parseInt(manualSolutionCountInput.value) || 0;

            // Update A display
            varAUnitDisplay.textContent = `${A_inches.toFixed(2)} in. (Used in calculation)`;

            if (isNaN(A_feet) || A_feet <= 0) {
                visualTable.innerHTML = '<p style="color:red; padding:10px;">Please enter a valid value for A (Total Width).</p>';
                varBInput.value = 'N/A';
                varXInput.value = 'N/A';
                return;
            }

            // Parse item groups based on new structured input
            const itemGroups = parseItemGroups(itemWidthsInput.value, expectedSolutionGroups);
            const numSolutionGroups = itemGroups.length;
            
            if (numSolutionGroups !== expectedSolutionGroups) {
                 console.warn(`Pattern defined ${numSolutionGroups} groups, but expected ${expectedSolutionGroups}. Using ${numSolutionGroups} for calculation.`);
            }
            
            if (numSolutionGroups === 0) {
                 visualTable.innerHTML = '<p style="color:red; padding:10px;"><b>Error:</b> Please provide at least one valid item width.</p>';
                 numSignsInput.value = 0;
                 return;
            }

            // 3. CALCULATE B (Sum of all item widths + Signage contribution + Internal Gap width)
            let B_itemSum = 0;
            let totalSignsUsed = 0;
            let totalInternalGapsUsed = 0; 
            
            for (const group of itemGroups) {
                for (let i = 0; i < group.length; i++) {
                    const item = group[i];
                    B_itemSum += item.width;
                    
                    // Count Signage if applicable (only before the first item of the group)
                    if (isSignageOn && item.isFirst) {
                        totalSignsUsed++;
                    }
                    
                    // Count Internal Gap (D) if this item is NOT the last item in the group
                    if (i < group.length - 1) {
                        totalInternalGapsUsed++;
                    }
                }
            }
            
            // Calculate signage width
            const signageTotalWidth = isSignageOn ? (totalSignsUsed * (SIGN_WIDTH_INCHES + SIGN_ITEM_GAP_INCHES)) : 0;
            
            // Calculate internal gap width
            const internalGapsTotalWidth = totalInternalGapsUsed * D;

            const B_totalWidth = B_itemSum + signageTotalWidth + internalGapsTotalWidth; // FINAL B CALCULATION
            
            // Update disabled sign count display
            numSignsInput.value = totalSignsUsed;

            // Display calculated B in both units
            varBInput.value = B_totalWidth.toFixed(2);
            varBUnitDisplay.textContent = `${convertInchesToFeet(B_totalWidth).toFixed(2)} ft / ${B_totalWidth.toFixed(2)} in.`;


            // 4. Calculate spacing (X)
            const result = calculateSpacing(A_inches, B_totalWidth, C, numSolutionGroups, selectedFormula, edgeFactor);

            if (result === null) {
                varXInput.value = 'ERROR';
                varXUnitDisplay.textContent = '---';
                varXFractionalDisplay.textContent = 'Fractional Value: N/A';
                visualTable.innerHTML = '<p style="color:red; padding:10px;"><b>Error:</b> Calculation impossible. Solutions are too wide, or invalid C.</p>';
                return;
            }

            const { spaceWidths, calculatedX } = result;
            
            // 5. Update the calculated X value on the screen
            varXInput.value = calculatedX.toFixed(2);
            varXUnitDisplay.textContent = `${convertInchesToFeet(calculatedX).toFixed(4)} ft / ${calculatedX.toFixed(2)} in.`;
            
            // Display fractional equivalent of X
            const fractionalX = decimalToFraction(calculatedX, 16); // Using 1/16th inch precision
            varXFractionalDisplay.textContent = `Fractional Value: ${fractionalX}`;


            // 6. Build the visual elements (Drawing Loop)
            const numSpaces = spaceWidths.length;
            let spaceIndex = 0;
            
            for (let i = 0; i < numSolutionGroups; i++) {
                const group = itemGroups[i];

                // 6a. Draw the main spacing *before* the item group
                if (spaceIndex < numSpaces) {
                     addVisualElement(spaceWidths[spaceIndex], A_inches, 'space', null, isMobile);
                     spaceIndex++;
                }

                // 6b. Draw the items and internal gaps within the group
                for (let j = 0; j < group.length; j++) {
                    const item = group[j];
                    
                    // Draw Signage if applicable (only if the toggle is ON AND it's the first item)
                    if (isSignageOn && item.isFirst) {
                        // Sign (3")
                        addVisualElement(SIGN_WIDTH_INCHES, A_inches, 'circle-sign', null, isMobile);
                        
                        // Gap (1")
                        addVisualElement(SIGN_ITEM_GAP_INCHES, A_inches, 'item-sign-gap', null, isMobile);
                    }

                    // Draw the Item (Rectangle)
                    addVisualElement(item.width, A_inches, 'rectangle-item', `Item: ${item.width.toFixed(2)} in.`, isMobile);
                    
                    // NEW: Draw the internal gap (D) if this item is NOT the last item in the group
                    if (j < group.length - 1) {
                         addVisualElement(D, A_inches, 'internal-gap', `D: ${D.toFixed(2)} in.`, isMobile);
                    }
                }
            }
            
            // 6d. Add any remaining spaces (the space after the last item group)
            if (spaceIndex < numSpaces) {
                addVisualElement(spaceWidths[spaceIndex], A_inches, 'space', null, isMobile);
            }
            
            // Ensure zoom is applied immediately after visualization updates
            applyZoom(); 
        }

        /**
         * Helper function to create and add a single element (Space, Item, Sign, Gap) to the table
         * @param {string|null} labelOverride - Custom text for the label (used for Items).
         * @param {boolean} isMobile - Flag to indicate narrow screen mode.
         */
        function addVisualElement(widthInches, totalWidthInches, type, labelOverride = null, isMobile = false) {
            const el = document.createElement('div');
            el.className = type;
            const widthPercentage = (widthInches / totalWidthInches) * 100;
            el.style.width = widthPercentage + '%';
            
            const widthFeet = convertInchesToFeet(widthInches);
            
            // Create span for text content
            const span = document.createElement('span');
            
            // Customize label based on type
            let labelText;

            if (labelOverride) {
                labelText = labelOverride;
            } else if (type === 'circle-sign') {
                 labelText = `Sign: ${SIGN_WIDTH_INCHES.toFixed(0)} in.`
            } else if (type === 'item-sign-gap') {
                 labelText = `Gap: ${SIGN_ITEM_GAP_INCHES.toFixed(0)} in.`
            } else if (type === 'internal-gap') { // Internal Gap Label
                 // D: X.XX in. or D: X.X in. (simplified on mobile)
                 labelText = `D: ${isMobile ? widthInches.toFixed(1) : widthInches.toFixed(2)} in.`
            } else if (type === 'space') {
                 // **FINAL FIX: Remove all feet references from the visual space label.**
                 labelText = `${widthInches.toFixed(2)} in.`
                 
                 /*
                 if (!isMobile) {
                      // Desktop/Tablet: APPEND the feet measurement if the screen is wide enough
                      const feetPart = ` / ${widthFeet.toFixed(3)}'`;
                      labelText += feetPart;
                 }
                 */
            } else {
                 labelText = `Solution Block`
            }

            span.textContent = labelText;
            
            // Apply INVERSE scale to the span (transform: scale(1/zoom))
            if (currentZoomLevel) {
                 // Base transform will be set in applyZoom, but ensures the element has a transform property
                 span.style.transform = 'none';
            }

            el.appendChild(span);
            el.title = `${type}: ${widthInches.toFixed(2)} in.`;
            visualTable.appendChild(el);
            return el;
        }

    </script>
</body>
</html>